<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fappr</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel CDN for JSX transformation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Dropbox Chooser (Drop-ins) -->
    <script id="dropboxjs" src="https://www.dropbox.com/static/api/2/dropins.js" data-app-key="9tde0tp2fac293v"></script>
    <style>
        /* Custom styles for the app */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; margin: 0; padding: 0; box-sizing: border-box; background-color: #111827; overflow-x: hidden; }
        
        .grid-item {
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 2px solid #374151;
            background-color: #1f2937;
        }
        .grid-item:hover {
            /* Remove bounce/move on hover */
            transform: none;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.5);
            border-color: #4b5563;
        }
        .grid-item.selected {
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px #3B82F6, 0 8px 15px rgba(59, 130, 246, 0.4);
        }
        .grid-item img, .grid-item video {
            width: 100%;
            height: auto;
            display: block;
        }
        /* Fixed-aspect media container to avoid layout jitter (square) */
        .media-thumb { position: relative; width: 100%; padding-top: 100%; background-color: #111827; }
        .media-thumb > img, .media-thumb > video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; display: block; }
        /* De-emphasize unsupported media */
        .grid-item.unsupported {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .grid-item .item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: opacity 0.2s ease-in-out;
            opacity: 0;
        }
        .grid-item:hover .item-name {
            opacity: 1;
        }
        .grid-item .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
        }
        /* Removed hover reveal on play icon to disable icon hover effects */
        .folder-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            text-align: center;
            color: #d1d5db;
            height: 150px; /* Give folders a consistent height */
        }
        .folder-item .item-name {
            position: static;
            opacity: 1;
            background: none;
            padding: 8px 0 0 0;
            z-index: 10;
        }
        .selection-checkmark {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            background-color: #3B82F6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            border: 2px solid white;
            z-index: 20;
        }

        /* Spinner for loading states */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        /* Media Viewer Modal */
        .viewer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .viewer-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .viewer-media {
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .viewer-control {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 2rem;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1010;
        }
        /* Removed viewer control hover background change to disable icon hover effects */
        .viewer-prev { left: 20px; }
        .viewer-next { right: 20px; }
        .viewer-close {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2.5rem;
            line-height: 1;
        }

        /* Landing page subtle shimmer background */
        .shimmer-box { position: relative; border-radius: 0.75rem; overflow: hidden; }
        .shimmer-box::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(1200px 800px at 10% -20%, rgba(59,130,246,0.14), rgba(59,130,246,0) 60%),
                        radial-gradient(1000px 700px at 110% 120%, rgba(147,197,253,0.12), rgba(147,197,253,0) 60%);
            pointer-events: none;
        }
        /* Disable shimmer sweep (animated background) on landing card */
        .shimmer-box::after { display: none; }
        /* Subtle page fade animation */
        @keyframes page-fade-in {
            from { opacity: 0; transform: translateY(4px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .page-fade { animation: page-fade-in 220ms ease-out; }

        /* Collage mode */
        .collage-board {
            position: relative;
            width: 100%;
            background: #0b1220;
            border: 1px solid #1f2937;
            border-radius: 12px;
            overflow: hidden;
        }
        .collage-slot {
            position: absolute;
            background: #0f172a;
            border: 1px dashed rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        .collage-slot .slot-empty {
            position: absolute; inset: 0;
            display: flex; align-items: center; justify-content: center;
            color: #d1d5db; font-weight: 600; background: rgba(255,255,255,0.02);
        }
        .collage-slot .slot-media { position: absolute; inset: 0; }
        .collage-slot .slot-media img, .collage-slot .slot-media video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
        .slot-pan-wrap { position: absolute; inset: 0; overflow: hidden; }
        .slot-pan-inner { position: absolute; inset: 0; will-change: transform; }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        

        // --- UTILITY FUNCTIONS ---

        // Checks for any video extension
        const isVideoFile = (fileName) => {
            const videoExtensions = ['.mp4', '.mov', '.wmv', '.avi', '.mkv', '.webm', '.flv'];
            return videoExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
        };

        // Checks for extensions the browser <video> tag supports for thumbnails
        const canGenerateThumbnail = (fileName) => {
            const supportedExtensions = ['.mp4', '.webm', '.ogg']; 
            return supportedExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
        };

        // Checks whether a video is likely playable in-browser on macOS by extension
        const isBrowserSupportedVideo = (fileName) => {
            const supportedExtensions = ['.mp4', '.webm', '.ogg', '.mov'];
            return supportedExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
        };

        // A more robust helper function to generate a thumbnail from a video URL
        const generateVideoThumbnail = (videoUrl) => {
            const thumbnailPromise = new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.crossOrigin = 'anonymous';
                video.muted = true;
                video.playsInline = true;

                let hasFired = false;

                const cleanup = () => {
                    video.removeEventListener('loadedmetadata', onLoadedMetadata);
                    video.removeEventListener('seeked', onSeeked);
                    video.removeEventListener('error', onError);
                    video.src = ''; // Release the object URL and memory
                };

                const onSeeked = () => {
                    if (hasFired) return;
                    hasFired = true;
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        if (canvas.width === 0) {
                            cleanup();
                            reject(new Error('Canvas width is 0.'));
                            return;
                        }
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        cleanup();
                        resolve(canvas.toDataURL('image/jpeg'));
                    } catch (e) {
                        cleanup();
                        reject(e);
                    }
                };

                const onLoadedMetadata = () => {
                    if (video.duration) {
                        video.currentTime = video.duration * 0.1;
                    } else {
                        video.currentTime = 0.1;
                    }
                };
                
                const onError = (e) => {
                    if (hasFired) return;
                    hasFired = true;
                    cleanup();
                    reject(new Error('Video element error: ' + (e.message || 'Unknown error')));
                };

                video.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
                video.addEventListener('seeked', onSeeked, { once: true });
                video.addEventListener('error', onError, { once: true });
                
                video.src = videoUrl;
            });

            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Thumbnail generation timed out')), 5000);
            });

            return Promise.race([thumbnailPromise, timeoutPromise]);
        };

        // Date helpers for grouping
        const startOfDay = (d) => { const x = new Date(d); x.setHours(0,0,0,0); return x; };
        const addDays = (d, n) => { const x = new Date(d); x.setDate(x.getDate() + n); return x; };
        const isSameDay = (a, b) => startOfDay(a).getTime() === startOfDay(b).getTime();
        const isYesterday = (d, now=new Date()) => isSameDay(d, addDays(startOfDay(now), -1));
        const startOfWeek = (d) => { const x = startOfDay(d); const day = (x.getDay()+6)%7; // Mon=0
            x.setDate(x.getDate() - day); return x; };
        const isSameWeek = (d, now=new Date()) => startOfWeek(d).getTime() === startOfWeek(now).getTime();
        const isLastWeek = (d, now=new Date()) => startOfWeek(d).getTime() === addDays(startOfWeek(now), -7).getTime();
        const isSameMonth = (d, now=new Date()) => d.getFullYear()===now.getFullYear() && d.getMonth()===now.getMonth();
        const isLastMonth = (d, now=new Date()) => {
            const y = now.getMonth() === 0 ? now.getFullYear()-1 : now.getFullYear();
            const m = now.getMonth() === 0 ? 11 : now.getMonth()-1;
            return d.getFullYear()===y && d.getMonth()===m;
        };
        const weekdayName = (d) => d.toLocaleDateString(undefined, { weekday: 'long' });

        // Compute folder aggregates (modifiedAt as latest child, size as sum)
        const computeFolderAggregates = (folderNode) => {
            if (!folderNode || !folderNode.children) return { latest: 0, total: 0, hasSupported: false, hasUnsupported: false };
            let latest = 0;
            let total = 0;
            let hasSupported = false;
            let hasUnsupported = false;
            for (const child of folderNode.children) {
                if (child.type === 'folder') {
                    const agg = computeFolderAggregates(child);
                    if (agg.latest > latest) latest = agg.latest;
                    total += agg.total;
                    if (agg.hasSupported) hasSupported = true;
                    if (agg.hasUnsupported) hasUnsupported = true;
                    // write back
                    child.modifiedAt = child.modifiedAt || agg.latest;
                    child.size = typeof child.size === 'number' ? child.size : agg.total;
                } else {
                    if (child.modifiedAt && child.modifiedAt > latest) latest = child.modifiedAt;
                    if (typeof child.size === 'number') total += child.size;
                    if (child.type === 'photo' || (child.type === 'video' && !child.unsupported)) hasSupported = true;
                    if (child.type === 'video' && child.unsupported) hasUnsupported = true;
                }
            }
            folderNode.modifiedAt = folderNode.modifiedAt || latest;
            folderNode.size = typeof folderNode.size === 'number' ? folderNode.size : total;
            folderNode.unsupportedOnly = hasUnsupported && !hasSupported;
            return { latest, total, hasSupported, hasUnsupported };
        };

        // Assign folder thumbnails from child video files (post-order)
        const assignFolderThumbnailsFromVideos = async (folderNode) => {
            if (!folderNode || !folderNode.children) return;
            // First process all subfolders
            for (const child of folderNode.children) {
                if (child.type === 'folder') {
                    await assignFolderThumbnailsFromVideos(child);
                }
            }
            // If already has a thumbnail, nothing to do
            if (folderNode.thumbnail) return;
            // Prefer bubbling up from subfolders that now have thumbnails
            const subWithThumb = folderNode.children.find(c => c.type === 'folder' && c.thumbnail);
            if (subWithThumb) {
                folderNode.thumbnail = subWithThumb.thumbnail;
                return;
            }
            // Otherwise, try to generate from a directly-contained supported video
            const videoChild = folderNode.children.find(c => c.type === 'video' && canGenerateThumbnail(c.name));
            if (videoChild) {
                try {
                    const thumb = await generateVideoThumbnail(videoChild.displaySrc);
                    folderNode.thumbnail = thumb;
                    if (!videoChild.thumbnail) videoChild.thumbnail = thumb;
                } catch (e) {
                    // ignore failures, leave folder without a thumbnail
                }
            }
        };

        // Normalize a filename for cover matching: drop extension and common suffixes
        const normalizeBaseForCover = (name) => {
            const base = (name || '').replace(/\.[^.]+$/, '');
            return base.replace(/[-_ ]?(cover|thumbnail|thumb|poster|folder)$/i, '').toLowerCase();
        };

        // Pair non-hidden "cover" images with videos and folders, and hide those images from listings
        const pairCoversAndHide = (folderNode) => {
            if (!folderNode || folderNode.type !== 'folder' || !Array.isArray(folderNode.children)) return;
            // Recurse first
            for (const child of folderNode.children) {
                if (child.type === 'folder') pairCoversAndHide(child);
            }
            const images = folderNode.children.filter(c => c.type === 'photo');
            const videos = folderNode.children.filter(c => c.type === 'video');

            const imagesByKey = new Map();
            for (const img of images) {
                const key = normalizeBaseForCover(img.name || '');
                if (!imagesByKey.has(key)) imagesByKey.set(key, []);
                imagesByKey.get(key).push(img);
            }

            const preferCoverNamed = (arr) => {
                if (!arr || arr.length === 0) return null;
                return arr.find(x => /(?:cover|thumbnail|thumb|poster|folder)/i.test(x.name || '')) || arr[0];
            };

            // Folder thumbnail from non-hidden cover file named after the folder
            if (!folderNode.thumbnail) {
                const key = (folderNode.name || '').toLowerCase();
                const cand = preferCoverNamed(imagesByKey.get(key) || []);
                if (cand) {
                    folderNode.thumbnail = cand.thumbnail || cand.displaySrc;
                    cand.__suppress = true;
                }
            }

            // Pair videos with matching cover images
            for (const v of videos) {
                if (v.thumbnail) continue;
                const key = normalizeBaseForCover(v.name || '');
                const arr = imagesByKey.get(key) || [];
                const chosen = preferCoverNamed(arr);
                if (chosen) {
                    v.thumbnail = chosen.thumbnail || chosen.displaySrc;
                    chosen.__suppress = true;
                }
            }

            // Remove suppressed images from this folder's children
            folderNode.children = folderNode.children.filter(c => !(c.type === 'photo' && c.__suppress));
        };


        // --- COMPONENTS ---

        /**
         * MediaViewerModal: A modal for viewing a single photo or video.
         */
        const MediaViewerModal = ({ media, collection, currentIndex, onClose, onNext, onPrevious, onStartPip, pips, onClosePip, onMovePip }) => {
            const videoRef = useRef(null);
            const [volume, setVolume] = useState(1);
            const [showVolumeIndicator, setShowVolumeIndicator] = useState(false);
            const volumeTimeoutRef = useRef(null);
            const [showScrubIndicator, setShowScrubIndicator] = useState(false);
            const [scrubDelta, setScrubDelta] = useState(0);
            const scrubTimeoutRef = useRef(null);
            const touchRef = useRef({ active:false, startX:0, startY:0, mode:null, lastX:0, lastY:0, baseTime:0 });
            const [showMeta, setShowMeta] = useState(true);
            const metaTimeoutRef = useRef(null);
            const photoSwipeRef = useRef({ startX:0, startY:0 });

            // Effect to sync volume state with the video element
            useEffect(() => {
                const videoElement = videoRef.current;
                if (media.type === 'video' && videoElement) {
                    const handleVolumeChange = () => setVolume(videoElement.volume);
                    setVolume(videoElement.volume); // Set initial volume
                    videoElement.addEventListener('volumechange', handleVolumeChange);
                    return () => videoElement.removeEventListener('volumechange', handleVolumeChange);
                }
            }, [media]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    resetMetaTimer();
                    if (e.key === 'ArrowRight') onNext();
                    if (e.key === 'ArrowLeft') onPrevious();
                    if (e.key === 'Escape') onClose();

                    // Handle volume controls for videos
                    if (media.type === 'video' && videoRef.current) {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault();
                            videoRef.current.volume = e.key === 'ArrowUp' 
                                ? Math.min(1, videoRef.current.volume + 0.1)
                                : Math.max(0, videoRef.current.volume - 0.1);

                            setShowVolumeIndicator(true);
                            if (volumeTimeoutRef.current) clearTimeout(volumeTimeoutRef.current);
                            volumeTimeoutRef.current = setTimeout(() => setShowVolumeIndicator(false), 1500);
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    if (volumeTimeoutRef.current) clearTimeout(volumeTimeoutRef.current);
                };
            }, [onNext, onPrevious, onClose, media]);

            useEffect(() => () => {
                if (volumeTimeoutRef.current) clearTimeout(volumeTimeoutRef.current);
                if (scrubTimeoutRef.current) clearTimeout(scrubTimeoutRef.current);
                if (metaTimeoutRef.current) clearTimeout(metaTimeoutRef.current);
            }, []);

            const resetMetaTimer = () => {
                setShowMeta(true);
                if (metaTimeoutRef.current) clearTimeout(metaTimeoutRef.current);
                metaTimeoutRef.current = setTimeout(() => setShowMeta(false), 2500);
            };

            useEffect(() => {
                // show meta then schedule hide when media changes
                resetMetaTimer();
            }, [media]);

            if (!media) return null;

            const beginTouch = (e) => {
                if (media.type !== 'video' || !videoRef.current) return;
                const t = e.changedTouches ? e.changedTouches[0] : e.touches[0];
                touchRef.current = { active:true, startX:t.clientX, startY:t.clientY, lastX:t.clientX, lastY:t.clientY, mode:null, baseTime: videoRef.current.currentTime || 0 };
            };
            const moveTouch = (e) => {
                if (!touchRef.current.active || media.type !== 'video' || !videoRef.current) return;
                const t = e.changedTouches ? e.changedTouches[0] : e.touches[0];
                const dx = t.clientX - touchRef.current.startX;
                const dy = t.clientY - touchRef.current.startY;
                const threshold = 12;
                if (!touchRef.current.mode) {
                    if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
                    touchRef.current.mode = Math.abs(dx) > Math.abs(dy) ? 'scrub' : 'volume';
                }
                if (touchRef.current.mode === 'volume') {
                    e.preventDefault();
                    const change = (-dy) * 0.0025; // ~40px => 0.1 volume
                    const v = Math.max(0, Math.min(1, (videoRef.current.volume || 0) + change));
                    videoRef.current.volume = v;
                    setShowVolumeIndicator(true);
                    if (volumeTimeoutRef.current) clearTimeout(volumeTimeoutRef.current);
                    volumeTimeoutRef.current = setTimeout(() => setShowVolumeIndicator(false), 800);
                } else if (touchRef.current.mode === 'scrub') {
                    e.preventDefault();
                    const pxPerSec = 10; // 10px = 1s
                    const offset = dx / pxPerSec;
                    setScrubDelta(offset);
                    setShowScrubIndicator(true);
                    if (scrubTimeoutRef.current) clearTimeout(scrubTimeoutRef.current);
                    scrubTimeoutRef.current = setTimeout(() => setShowScrubIndicator(false), 600);
                }
                touchRef.current.lastX = t.clientX;
                touchRef.current.lastY = t.clientY;
            };
            const endTouch = () => {
                if (!touchRef.current.active || media.type !== 'video' || !videoRef.current) return;
                if (touchRef.current.mode === 'scrub') {
                    const dur = videoRef.current.duration || Infinity;
                    const target = Math.max(0, Math.min(dur, touchRef.current.baseTime + scrubDelta));
                    try { videoRef.current.currentTime = target; } catch(_) {}
                }
                touchRef.current.active = false;
                touchRef.current.mode = null;
            };

            return (
                <div className="viewer-overlay page-fade" onClick={onClose} onMouseMove={resetMetaTimer} onTouchStart={resetMetaTimer}>
                    <button className="viewer-control viewer-close" onClick={onClose}>&times;</button>
                    {media.type === 'video' && !media.unsupported && (
                        <button
                            className="absolute top-4 right-16 bg-blue-600 text-white text-sm md:text-base px-3 py-1.5 rounded z-20 hover:bg-blue-700 shadow"
                            onClick={(e)=>{ e.stopPropagation(); try { videoRef.current && videoRef.current.pause(); } catch(_){}; onStartPip && onStartPip(); }}
                        >
                            PIP
                        </button>
                    )}
                    {collection.length > 1 && (
                        <>
                            <button className="viewer-control viewer-prev" onClick={(e) => { e.stopPropagation(); onPrevious(); }}>&#8249;</button>
                            <button className="viewer-control viewer-next" onClick={(e) => { e.stopPropagation(); onNext(); }}>&#8250;</button>
                        </>
                    )}
                    <div className="viewer-content">
                        {media.type === 'photo' ? (
                            <img
                                src={media.displaySrc}
                                alt={media.name}
                                className="viewer-media"
                                onClick={(e) => e.stopPropagation()}
                                onTouchStart={(e)=>{
                                    const t = e.changedTouches ? e.changedTouches[0] : e.touches[0];
                                    photoSwipeRef.current = { startX: t.clientX, startY: t.clientY };
                                }}
                                onTouchEnd={(e)=>{
                                    const t = e.changedTouches ? e.changedTouches[0] : e.touches[0];
                                    const dx = t.clientX - photoSwipeRef.current.startX;
                                    const dy = t.clientY - photoSwipeRef.current.startY;
                                    if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
                                        e.stopPropagation();
                                        if (dx < 0) onNext(); else onPrevious();
                                    }
                                }}
                            />
                        ) : media.unsupported ? (
                            <div className="viewer-media flex items-center justify-center text-center text-white bg-black bg-opacity-40" onClick={(e) => e.stopPropagation()}>
                                <div>
                                    <div className="text-2xl font-semibold mb-2">Unsupported Video</div>
                                    <div className="text-gray-300">This format cannot play in your browser.</div>
                                </div>
                            </div>
                        ) : (
                            <video
                                ref={videoRef}
                                src={media.displaySrc}
                                className="viewer-media"
                                controls
                                autoPlay
                                onClick={(e) => e.stopPropagation()}
                                onEnded={onNext}
                                onLoadedMetadata={(e)=>{ try { e.currentTarget.volume = 0.1; } catch(_){} }}
                                onTouchStart={beginTouch}
                                onTouchMove={moveTouch}
                                onTouchEnd={endTouch}
                            />
                        )}
                    </div>
                    {/* PIP overlay */}
                    {Array.isArray(pips) && pips.map((pipItem, idx) => (
                        pipItem && pipItem.media ? (
                            <div
                                key={`pip-${idx}`}
                                className={`group absolute ${pipItem.position.y === 'top' ? (pipItem.position.x === 'right' ? 'top-16' : 'top-4') : 'bottom-4'} ${pipItem.position.x === 'left' ? 'left-4' : 'right-4'} z-30`}
                                style={{ maxWidth: pipItem.media.type === 'photo' ? '60vw' : '40vw', maxHeight: pipItem.media.type === 'photo' ? '70vh' : '40vh' }}
                                onClick={(e)=> e.stopPropagation()}
                            >
                                <div className="relative rounded-lg overflow-hidden shadow-xl border border-gray-700 bg-black/60">
                                    {pipItem.media.type === 'photo' ? (
                                        <img src={pipItem.media.src} alt="PIP" className="block w-auto h-auto max-w-[60vw] max-h-[70vh] object-contain" />
                                    ) : (
                                        <video src={pipItem.media.src} className="block w-auto h-auto max-w-[40vw] max-h-[40vh]" autoPlay loop playsInline controls muted />
                                    )}
                                    {/* Top overlay: move controls and close (shows on hover) */}
                                    <div className="absolute inset-x-0 top-0 p-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <div className="flex items-center justify-between">
                                            <div className="bg-black/70 text-white text-sm rounded-full px-3 py-1 flex items-center gap-3">
                                                <button className="px-1" onClick={(e)=>{ e.stopPropagation(); onMovePip && onMovePip(idx, 'up'); }}>↑</button>
                                                <button className="px-1" onClick={(e)=>{ e.stopPropagation(); onMovePip && onMovePip(idx, 'down'); }}>↓</button>
                                                <button className="px-1" onClick={(e)=>{ e.stopPropagation(); onMovePip && onMovePip(idx, 'left'); }}>←</button>
                                                <button className="px-1" onClick={(e)=>{ e.stopPropagation(); onMovePip && onMovePip(idx, 'right'); }}>→</button>
                                            </div>
                                            <button className="bg-black/70 text-white text-xs px-2 py-1 rounded" onClick={(e)=>{ e.stopPropagation(); onClosePip && onClosePip(idx); }}>Close</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ) : null
                    ))}
                    <div
                        className={`absolute bottom-4 left-1/2 -translate-x-1/2 text-white text-xs sm:text-sm bg-black bg-opacity-60 px-3 py-1.5 rounded-full shadow-md transition-opacity duration-300 ${showMeta ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <span className="truncate max-w-[75vw] inline-block align-middle">{media.name}</span>
                        <span className="opacity-80 ml-2">({currentIndex + 1} / {collection.length})</span>
                    </div>
                    {showVolumeIndicator && media.type === 'video' && (
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-60 text-white px-4 py-2 rounded-lg z-20 flex items-center gap-3 transition-opacity duration-300">
                            <span className="font-semibold">VOL</span>
                            <div className="w-28 h-2 bg-gray-500 rounded-full overflow-hidden">
                                <div className="h-full bg-white rounded-full" style={{ width: `${volume * 100}%` }}></div>
                            </div>
                        </div>
                    )}
                    {showScrubIndicator && media.type === 'video' && (
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-60 text-white px-4 py-2 rounded-lg z-20 flex items-center gap-2">
                            <span className="font-semibold">{scrubDelta >= 0 ? '>>' : '<<'}</span>
                            <span>{`${scrubDelta >= 0 ? '+' : ''}${Math.round(scrubDelta)}s`}</span>
                        </div>
                    )}
                </div>
            );
        };
        
        const Breadcrumbs = ({ path, onNavigate }) => (
            <nav className="flex items-center flex-wrap text-gray-300 mb-2 bg-gray-800/80 px-2 py-1 rounded-md text-xs">
                {path.map((part, index) => (
                    <React.Fragment key={index}>
                        <button onClick={() => onNavigate(index)} className="text-blue-400 hover:underline whitespace-nowrap">{part}</button>
                        {index < path.length - 1 && <span className="mx-1 text-gray-500">/</span>}
                    </React.Fragment>
                ))}
            </nav>
        );

        const GridItem = ({ item, onClick, isFavorite, onToggleFavorite }) => {
            const [thumbnail, setThumbnail] = useState(item.thumbnail);
            const ref = useRef();

            useEffect(() => {
                const currentRef = ref.current;
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        if (entry.isIntersecting) {
                            if (item.type === 'video' && !thumbnail && canGenerateThumbnail(item.name)) {
                                generateVideoThumbnail(item.displaySrc)
                                    .then(setThumbnail)
                                    .catch(err => console.error("Thumbnail failed for", item.name, err));
                            }
                            // Once it's visible and we've tried to load, we don't need to watch anymore
                            observer.unobserve(currentRef);
                        }
                    },
                    { rootMargin: '200px' } // Pre-load images 200px before they enter the viewport
                );

                if (currentRef) {
                    observer.observe(currentRef);
                }

                return () => {
                    if (currentRef) {
                        observer.unobserve(currentRef);
                    }
                };
            }, [item, thumbnail]);


            const isSelected = item.isSelected;

            return (
                <div ref={ref} className={`grid-item ${isSelected ? 'selected' : ''} ${item.type === 'video' && item.unsupported ? 'unsupported' : ''}`} onClick={() => onClick(item)}>
                    {(item.type === 'photo' || item.type === 'video') && (
                        <button
                            className={`absolute top-2 right-2 z-20 rounded-full p-1 bg-black/60 hover:bg-black/80 transition ${isFavorite && isFavorite(item) ? 'text-yellow-300' : 'text-white'}`}
                            onClick={(e)=>{ e.stopPropagation(); onToggleFavorite && onToggleFavorite(item); }}
                            aria-label={isFavorite && isFavorite(item) ? 'Unfavorite' : 'Favorite'}
                            title={isFavorite && isFavorite(item) ? 'Unfavorite' : 'Favorite'}
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" className="h-5 w-5" fill={isFavorite && isFavorite(item) ? 'currentColor' : 'none'} stroke="currentColor" strokeWidth="1.6">
                                <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.063 4.186a.563.563 0 00.424.308l4.626.672c.523.076.732.72.354 1.09l-3.346 3.262a.563.563 0 00-.162.498l.79 4.6a.562.562 0 01-.815.592l-4.13-2.17a.563.563 0 00-.524 0l-4.13 2.17a.562.562 0 01-.816-.592l.79-4.6a.563.563 0 00-.162-.498l-3.346-3.262a.562.562 0 01.354-1.09l4.626-.672a.563.563 0 00.424-.308l2.063-4.186z" />
                            </svg>
                        </button>
                    )}
                    {isSelected && (
                        <div className="selection-checkmark">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                            </svg>
                        </div>
                    )}
                    {item.type === 'folder' ? (
                        <>
                            <div className="media-thumb">
                                {thumbnail && (
                                    <img src={thumbnail} alt={`${item.name} thumbnail`} className="opacity-30" />
                                )}
                                <div className="absolute inset-0 flex items-center justify-center z-10">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" style={{filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.7))'}}>
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                    </svg>
                                </div>
                                <div className="absolute bottom-2 left-1/2 -translate-x-1/2 z-10 w-4/5">
                                    <span
                                        className="bg-black/60 text-white text-xs sm:text-sm px-3 py-1.5 rounded-lg inline-block w-full text-center leading-snug break-words"
                                        style={{ display: '-webkit-box', WebkitLineClamp: 2, WebkitBoxOrient: 'vertical', overflow: 'hidden' }}
                                    >
                                        {item.name}
                                    </span>
                                </div>
                            </div>
                        </>
                    ) : item.type === 'photo' ? (
                        <>
                            {/* Top-left photo icon with subtle translucent background */}
                            <div className="absolute top-2 left-2 z-10 opacity-90 bg-white/70 rounded-md p-0.5 shadow pointer-events-none">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fillRule="evenodd" clipRule="evenodd" d="M9.77778 21H14.2222C17.3433 21 18.9038 21 20.0248 20.2646C20.51 19.9462 20.9267 19.5371 21.251 19.0607C22 17.9601 22 16.4279 22 13.3636C22 10.2994 22 8.76721 21.251 7.6666C20.9267 7.19014 20.51 6.78104 20.0248 6.46268C19.3044 5.99013 18.4027 5.82123 17.022 5.76086C16.3631 5.76086 15.7959 5.27068 15.6667 4.63636C15.4728 3.68489 14.6219 3 13.6337 3H10.3663C9.37805 3 8.52715 3.68489 8.33333 4.63636C8.20412 5.27068 7.63685 5.76086 6.978 5.76086C5.59733 5.82123 4.69555 5.99013 3.97524 6.46268C3.48995 6.78104 3.07328 7.19014 2.74902 7.6666C2 8.76721 2 10.2994 2 13.3636C2 16.4279 2 17.9601 2.74902 19.0607C3.07328 19.5371 3.48995 19.9462 3.97524 20.2646C5.09624 21 6.65675 21 9.77778 21ZM12 9.27273C9.69881 9.27273 7.83333 11.1043 7.83333 13.3636C7.83333 15.623 9.69881 17.4545 12 17.4545C14.3012 17.4545 16.1667 15.623 16.1667 13.3636C16.1667 11.1043 14.3012 9.27273 12 9.27273ZM12 10.9091C10.6193 10.9091 9.5 12.008 9.5 13.3636C9.5 14.7192 10.6193 15.8182 12 15.8182C13.3807 15.8182 14.5 14.7192 14.5 13.3636C14.5 12.008 13.3807 10.9091 12 10.9091ZM16.7222 10.0909C16.7222 9.63904 17.0953 9.27273 17.5556 9.27273H18.6667C19.1269 9.27273 19.5 9.63904 19.5 10.0909C19.5 10.5428 19.1269 10.9091 18.6667 10.9091H17.5556C17.0953 10.9091 16.7222 10.5428 16.7222 10.0909Z" fill="#1C274C"/>
                                </svg>
                            </div>
                            <div className="media-thumb">
                                <img src={thumbnail} alt={item.name} loading="lazy" />
                            </div>
                            <div className="item-name">{item.name}</div>
                        </>
                    ) : ( // item.type === 'video'
                        <>
                            {/* Top-left video icon with subtle translucent background */}
                            <div className="absolute top-2 left-2 z-10 opacity-90 bg-white/70 rounded-md p-0.5 shadow pointer-events-none">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path fillRule="evenodd" clipRule="evenodd" d="M15.3276 7.54199H8.67239C5.29758 7.54199 3.61017 7.54199 2.66232 8.52882C1.71447 9.51565 1.93748 11.0403 2.38351 14.0895L2.80648 16.9811C3.15626 19.3723 3.33115 20.5679 4.22834 21.2839C5.12553 21.9999 6.4488 21.9999 9.09534 21.9999H14.9046C17.5512 21.9999 18.8745 21.9999 19.7717 21.2839C20.6689 20.5679 20.8437 19.3723 21.1935 16.9811L21.6165 14.0895C22.0625 11.0403 22.2855 9.51564 21.3377 8.52882C20.3898 7.54199 18.7024 7.54199 15.3276 7.54199ZM14.5812 15.7942C15.1396 15.448 15.1396 14.5519 14.5812 14.2057L11.2096 12.1156C10.6669 11.7792 10 12.2171 10 12.9098V17.0901C10 17.7828 10.6669 18.2207 11.2096 17.8843L14.5812 15.7942Z" fill="#1C274C"/>
                                    <path opacity="0.4" d="M8.50956 2.00001H15.4897C15.7221 1.99995 15.9004 1.99991 16.0562 2.01515C17.164 2.12352 18.0708 2.78958 18.4553 3.68678H5.54395C5.92846 2.78958 6.83521 2.12352 7.94303 2.01515C8.09884 1.99991 8.27708 1.99995 8.50956 2.00001Z" fill="#1C274C"/>
                                    <path opacity="0.7" d="M6.3102 4.72266C4.91958 4.72266 3.77931 5.56241 3.39878 6.67645C3.39085 6.69967 3.38325 6.72302 3.37598 6.74647C3.77413 6.6259 4.18849 6.54713 4.60796 6.49336C5.68833 6.35485 7.05367 6.35492 8.6397 6.35501H15.5318C17.1178 6.35492 18.4832 6.35485 19.5635 6.49336C19.983 6.54713 20.3974 6.6259 20.7955 6.74647C20.7883 6.72302 20.7806 6.69967 20.7727 6.67645C20.3922 5.56241 19.2519 4.72266 17.8613 4.72266H6.3102Z" fill="#1C274C"/>
                                </svg>
                            </div>
                            <div className="media-thumb">
                                {thumbnail ? (
                                    <img src={thumbnail} alt={item.name} />
                                ) : (
                                    <div className="absolute inset-0 bg-gray-800 flex items-center justify-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 text-blue-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
                                            <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9A2.25 2.25 0 0013.5 5.25h-9A2.25 2.25 0 002.25 7.5v9A2.25 2.25 0 004.5 18.75z" />
                                        </svg>
                                    </div>
                                )}
                            </div>
                            {item.unsupported && (
                                <div className="absolute top-2 left-10 bg-red-600 text-white text-xs font-semibold px-2 py-1 rounded shadow">
                                    Unsupported
                                </div>
                            )}
                            {!item.unsupported && (
                                <div className="play-icon">
                                    <svg width="24" height="24" fill="white" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                                </div>
                            )}
                            <div className="item-name">{item.name}</div>
                        </>
                    )}
                </div>
            );
        };

        const MediaLibrary = ({ items, path, onMediaClick, onFolderClick, onNavigate, onUploadNew, onStartCollage, selectionMode, setSelectionMode, selectedItems, toggleSelection, isRecursiveView, setIsRecursiveView, hasSubfolders, specialView, setSpecialView, isFavorite, onToggleFavorite, onClearFavorites }) => {
            const [search, setSearch] = useState('');
            const [sortMode, setSortMode] = useState(() => localStorage.getItem('fappr.sortMode') || localStorage.getItem('roostr.sortMode') || 'name'); // 'name' | 'date' | 'size'
            const [filterType, setFilterType] = useState(() => localStorage.getItem('fappr.filterType') || localStorage.getItem('roostr.filterType') || 'all');
            const [displayCount, setDisplayCount] = useState(200);
            const [numColumns, setNumColumns] = useState(5);

            const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);
            const getNumColumnsFor = (fs) => {
                const w = window.innerWidth;
                // On phones, always use two columns
                if (w < 640) return 2;
                if (w < 768) return fs ? 1 : 2;
                if (w < 1024) return fs ? 2 : 3;
                if (w < 1280) return fs ? 2 : 4;
                return fs ? 3 : 5;
            };
            useEffect(() => {
                const handleResize = () => setNumColumns(getNumColumnsFor(isFullscreen));
                handleResize();
                window.addEventListener('resize', handleResize);
                const onFs = () => {
                    const fs = !!document.fullscreenElement;
                    setIsFullscreen(fs);
                    setNumColumns(getNumColumnsFor(fs));
                };
                document.addEventListener('fullscreenchange', onFs);
                return () => { window.removeEventListener('resize', handleResize); document.removeEventListener('fullscreenchange', onFs); };
            }, [isFullscreen]);

            const toggleFullscreen = async () => {
                try {
                    if (!document.fullscreenElement) {
                        await document.documentElement.requestFullscreen();
                    } else {
                        await document.exitFullscreen();
                    }
                } catch (e) { /* no-op */ }
            };

            // Build set of video basenames to hide matching cover images
            const currentFolderNameLower = (path[path.length - 1] || '').toLowerCase();
            const normalizeCover = (name) => {
                const base = (name || '').replace(/\.[^.]+$/, '').toLowerCase();
                return base.replace(/[-_ ]?(cover|thumbnail|thumb|poster|folder)$/i, '');
            };
            const videoKeys = new Set(items.filter(i => i.type === 'video').map(v => normalizeCover(v.name)));

            const filteredItems = items.map(item => ({
                ...item,
                isSelected: selectedItems.some(selected => selected.id === item.id)
            })).filter(item => {
                const matchesSearch = item.name.toLowerCase().includes(search.toLowerCase());
                if (!matchesSearch) return false;
                // Hide cover/thumbnail images that match a sibling video or the folder name
                if (item.type === 'photo') {
                    const base = (item.name || '').replace(/\.[^.]+$/, '').toLowerCase();
                    const normalized = base.replace(/[-_ ]?(cover|thumbnail|thumb|poster|folder)$/i, '');
                    const isCoverLike = normalized !== base;
                    if (isCoverLike && (videoKeys.has(normalized) || normalized === currentFolderNameLower)) return false;
                }
                if (item.type !== 'folder' && filterType !== 'all' && item.type !== filterType) return false;
                // Exclude unsupported videos and unsupported-only folders from main listing
                if (item.type === 'video' && item.unsupported) return false;
                if (item.type === 'folder' && item.unsupportedOnly) return false;
                return true;
            }).sort((a, b) => {
                if (sortMode === 'name') {
                    // Folders first, then A-Z
                    if (a.type === 'folder' && b.type !== 'folder') return -1;
                    if (a.type !== 'folder' && b.type === 'folder') return 1;
                    return a.name.localeCompare(b.name);
                } else if (sortMode === 'size') {
                    // Folders first (by name), then files by size desc then name
                    if (a.type === 'folder' && b.type !== 'folder') return -1;
                    if (a.type !== 'folder' && b.type === 'folder') return 1;
                    if (a.type === 'folder' && b.type === 'folder') {
                        return a.name.localeCompare(b.name);
                    }
                    const aSize = a.size || 0;
                    const bSize = b.size || 0;
                    if (aSize !== bSize) return bSize - aSize;
                    return a.name.localeCompare(b.name);
                } else if (sortMode === 'date') {
                    const aTime = a.modifiedAt || 0;
                    const bTime = b.modifiedAt || 0;
                    if (aTime !== bTime) return bTime - aTime; // newest first
                    return a.name.localeCompare(b.name);
                }
                return a.name.localeCompare(b.name);
            });

            useEffect(() => {
                setDisplayCount(200);
            }, [items, search, sortMode, filterType]);

            useEffect(() => { try { localStorage.setItem('fappr.sortMode', sortMode); } catch(_){} }, [sortMode]);
            useEffect(() => { try { localStorage.setItem('fappr.filterType', filterType); } catch(_){} }, [filterType]);

            const itemsToShow = filteredItems.slice(0, displayCount);
            const fileItems = filteredItems.filter(item => item.type !== 'folder');
            
            const columns = Array.from({ length: numColumns }, () => []);
            itemsToShow.forEach((item, index) => {
                columns[index % numColumns].push(item);
            });

            // Build date groups (folders and files) when in date mode
            const fileItemsByDate = React.useMemo(() => {
                if (sortMode !== 'date') return null;
                const all = filteredItems
                    .slice()
                    .sort((a,b) => (b.modifiedAt||0) - (a.modifiedAt||0));
                const sliced = all.slice(0, displayCount);
                const groups = [];
                const now = new Date();
                const buckets = new Map();
                const pushTo = (key, item) => { if (!buckets.has(key)) buckets.set(key, []); buckets.get(key).push(item); };
                for (const item of sliced) {
                    const d = new Date(item.modifiedAt || 0);
                    if (isNaN(d)) { pushTo('Older', item); continue; }
                    if (isSameDay(d, now)) { pushTo('Today', item); continue; }
                    if (isYesterday(d, now)) { pushTo('Yesterday', item); continue; }
                    if (isSameWeek(d, now)) { pushTo(weekdayName(d), item); continue; }
                    if (isLastWeek(d, now)) { pushTo('Last Week', item); continue; }
                    if (isSameMonth(d, now)) { pushTo('This Month', item); continue; }
                    if (isLastMonth(d, now)) { pushTo('Last Month', item); continue; }
                    const monthLabel = d.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
                    pushTo(monthLabel, item);
                }
                const preferredOrder = ['Today','Yesterday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday','Last Week','This Month','Last Month'];
                for (const key of preferredOrder) {
                    if (buckets.has(key)) groups.push({ title: key, items: buckets.get(key) });
                }
                // Add remaining chronological month groups
                for (const [key, arr] of buckets.entries()) {
                    if (!preferredOrder.includes(key)) groups.push({ title: key, items: arr });
                }
                return groups;
            }, [filteredItems, displayCount, sortMode]);

            // Unsupported videos list for extra section (always at bottom, full set regardless of pagination)
            const unsupportedDisplayed = React.useMemo(() => {
                const base = items.map(item => ({...item})).filter(i => {
                    const matchesSearch = i.name.toLowerCase().includes(search.toLowerCase());
                    if (!matchesSearch) return false;
                    if (i.type !== 'folder' && filterType !== 'all' && i.type !== filterType) return false;
                    return true;
                });
                const vids = base.filter(i => i.type === 'video' && i.unsupported);
                const unsupportedFolders = base.filter(i => i.type === 'folder' && i.unsupportedOnly);
                return [...unsupportedFolders, ...vids];
            }, [items, search, filterType]);

            const handleItemClick = (item) => {
                if (selectionMode) {
                    toggleSelection(item);
                } else {
                    item.type === 'folder' ? onFolderClick(item.name) : onMediaClick(item, fileItems);
                }
            };

            return (
                <div className="min-h-screen bg-gray-900 p-4 md:p-6">
                    <div className={`${isFullscreen ? 'max-w-[100vw]' : 'max-w-screen-2xl'} mx-auto page-fade`}>
                        <header className="sticky top-0 z-40 flex flex-col md:flex-row items-center justify-between gap-4 bg-gray-900/95 border-b border-gray-700 backdrop-blur px-4 py-3 -mx-4 md:-mx-6 mb-4">
                            <div className="flex items-center">
                               <img src="logo.png" alt="fappr Logo" className="w-10 h-10 mr-3" />
                               <h1 className="text-3xl font-bold text-white">fappr</h1>
                            </div>
                            <div className="flex items-center gap-4 flex-wrap">
                                <button onClick={onStartCollage} aria-label="Collage" className="hidden sm:inline-flex bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors order-0">
                                    Collage
                                </button>
                                <button onClick={onUploadNew} aria-label="Upload New Folder" className="bg-blue-600 text-white h-10 w-10 rounded-lg hover:bg-blue-700 transition-colors inline-flex items-center justify-center order-1" title="Upload New Folder">
                                    <svg className="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        {/* Folder outline */}
                                        <path d="M3 7v9.5A2.5 2.5 0 0 0 5.5 19h13a2.5 2.5 0 0 0 2.5-2.5V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2z" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
                                        {/* Up arrow inside folder */}
                                        <path d="M12 16V11" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round"/>
                                        <path d="M9.5 13.5 12 11l2.5 2.5" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round"/>
                                    </svg>
                                </button>
                                <button onClick={() => setSelectionMode(!selectionMode)} aria-label="Select" className={`bg-blue-600 text-white h-10 w-10 rounded-lg hover:bg-blue-700 transition-colors inline-flex items-center justify-center order-2`} title="Select">
                                    <svg className="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M9 12l2 2 4-4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                                        <rect x="4" y="4" width="16" height="16" rx="2" ry="2" stroke="currentColor" stroke-width="1.5"/>
                                    </svg>
                                </button>
                                <button onClick={toggleFullscreen} aria-label="Full Screen" className="bg-blue-600 text-white h-10 w-10 rounded-lg hover:bg-blue-700 transition-colors inline-flex items-center justify-center order-3" title="Full Screen">
                                    {isFullscreen ? (
                                        <>
                                            <svg className="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M9 3H5a2 2 0 0 0-2 2v4M15 21h4a2 2 0 0 0 2-2v-4M21 9V5a2 2 0 0 0-2-2h-4M3 15v4a2 2 0 0 0 2 2h4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/>
                                            </svg>
                                        </>
                                    ) : (
                                        <>
                                            <svg className="h-5 w-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M8 3H5a2 2 0 0 0-2 2v3M16 21h3a2 2 0 0 0 2-2v-3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/>
                                            </svg>
                                        </>
                                    )}
                                </button>
                                <button onClick={() => setSpecialView(specialView === 'favorites' ? null : 'favorites')} aria-label="Favorites" className={`h-10 w-10 rounded-lg inline-flex items-center justify-center transition-colors order-4 ${specialView === 'favorites' ? 'bg-yellow-500 text-black hover:bg-yellow-400' : 'bg-blue-600 text-white hover:bg-blue-700'}`} title="Favorites">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" className="h-5 w-5" fill={specialView==='favorites' ? 'currentColor' : 'none'} stroke="currentColor" strokeWidth="1.6">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.063 4.186a.563.563 0 00.424.308l4.626.672c.523.076.732.72.354 1.09l-3.346 3.262a.563.563 0 00-.162.498l.79 4.6a.562.562 0 01-.815.592l-4.13-2.17a.563.563 0 00-.524 0l-4.13 2.17a.562.562 0 01-.816-.592l.79-4.6a.563.563 0 00-.162-.498l-3.346-3.262a.562.562 0 01.354-1.09l4.626-.672a.563.563 0 00.424-.308l2.063-4.186z" />
                                    </svg>
                                </button>
                            </div>
                        </header>
                        
                        <Breadcrumbs
                            path={path}
                            onNavigate={(index)=>{
                                if (specialView === 'favorites') {
                                    // index 0 = root; exit favorites
                                    if (index === 0) {
                                        setSpecialView(null);
                                        return;
                                    }
                                    // index 1 = Favorites (no-op)
                                    return;
                                }
                                onNavigate(index);
                            }}
                        />

                        <div className="flex flex-wrap items-center gap-4 mb-6 bg-gray-800 p-4 rounded-lg">
                            <input type="text" placeholder="Search current folder..." value={search} onChange={(e) => setSearch(e.target.value)} className="flex-grow min-w-0 px-4 bg-gray-700 text-white rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none h-10" />
                            <div className="flex items-center gap-2 flex-wrap">
                                <div className="flex items-center gap-1 bg-gray-700 p-1 rounded-lg h-10">
                                    <button onClick={() => setFilterType('all')} className={`h-8 px-3 rounded-md text-sm transition-colors ${filterType === 'all' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>All</button>
                                    <button onClick={() => setFilterType('photo')} className={`h-8 px-3 rounded-md text-sm transition-colors ${filterType === 'photo' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>Photos</button>
                                    <button onClick={() => setFilterType('video')} className={`h-8 px-3 rounded-md text-sm transition-colors ${filterType === 'video' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>Videos</button>
                                </div>
                                <div className="flex items-center gap-1 bg-gray-700 p-1 rounded-lg h-10">
                                    <button onClick={() => setSortMode('name')} className={`h-8 px-3 rounded-md text-sm transition-colors ${sortMode === 'name' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>A to Z</button>
                                    <button onClick={() => setSortMode('date')} className={`h-8 px-3 rounded-md text-sm transition-colors ${sortMode === 'date' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>Date</button>
                                    <button onClick={() => setSortMode('size')} className={`h-8 px-3 rounded-md text-sm transition-colors ${sortMode === 'size' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>Size</button>
                                </div>
                                {hasSubfolders && (
                                    <button onClick={() => setIsRecursiveView(!isRecursiveView)} className="bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors ml-0 md:ml-4 h-10 px-4">
                                        {isRecursiveView ? 'Back to Folder View' : 'Group'}
                                    </button>
                                )}
                                {specialView === 'favorites' && (
                                    <button onClick={onClearFavorites} className="bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors h-10 px-4">Clear Favorites</button>
                                )}
                            </div>
                        </div>
                        {sortMode !== 'date' ? (
                            <>
                                <div className="flex flex-row gap-4 items-start p-5">
                                    {columns.map((column, colIndex) => (
                                        <div key={colIndex} className="flex flex-col gap-4 w-full">
                                            {column.map(item => <GridItem key={item.id} item={item} onClick={handleItemClick} isFavorite={isFavorite} onToggleFavorite={onToggleFavorite} />)}
                                        </div>
                                    ))}
                                </div>
                                {unsupportedDisplayed.length > 0 && (
                                    <div className="p-5 pt-0">
                                        <h2 className="text-gray-300 font-semibold mb-3">Unsupported Videos</h2>
                                        <div className="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                            {unsupportedDisplayed.map(item => (
                                                <GridItem key={`u-${item.id}`} item={item} onClick={handleItemClick} isFavorite={isFavorite} onToggleFavorite={onToggleFavorite} />
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </>
                        ) : (
                            <div className="p-5 space-y-8">
                                {fileItemsByDate && fileItemsByDate.map(group => (
                                    <section key={group.title}>
                                        <h2 className="text-gray-300 font-semibold mb-3">{group.title}</h2>
                                        <div className="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                            {group.items.map(item => (
                                                <GridItem key={item.id} item={item} onClick={handleItemClick} isFavorite={isFavorite} onToggleFavorite={onToggleFavorite} />
                                            ))}
                                        </div>
                                    </section>
                                ))}
                                {unsupportedDisplayed.length > 0 && (
                                    <section>
                                        <h2 className="text-gray-300 font-semibold mb-3">Unsupported Videos</h2>
                                        <div className="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                                            {unsupportedDisplayed.map(item => (
                                                <GridItem key={`u-${item.id}`} item={item} onClick={handleItemClick} isFavorite={isFavorite} onToggleFavorite={onToggleFavorite} />
                                            ))}
                                        </div>
                                    </section>
                                )}
                            </div>
                        )}
                        {displayCount < filteredItems.length && (
                             <div className="text-center mt-8 mb-4">
                                <button onClick={() => setDisplayCount(prev => Math.min(filteredItems.length, prev * 2))} className="bg-gray-700 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors font-semibold">
                                    Load More ({filteredItems.length - displayCount} remaining)
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const ImportScreen = ({ rawFileSystem, onImport, onCancel }) => {
            const [selectedIds, setSelectedIds] = useState(new Set());

            useEffect(() => {
                const topLevelIds = new Set(rawFileSystem.children.map(item => item.id));
                setSelectedIds(topLevelIds);
            }, [rawFileSystem]);

            const handleToggle = (item) => {
                const newSelectedIds = new Set(selectedIds);
                newSelectedIds.has(item.id) ? newSelectedIds.delete(item.id) : newSelectedIds.add(item.id);
                setSelectedIds(newSelectedIds);
            };
            
            const handleSelectAll = () => setSelectedIds(new Set(rawFileSystem.children.map(item => item.id)));
            const handleDeselectAll = () => setSelectedIds(new Set());

            const handleImportClick = () => {
                const importedSystem = {
                    ...rawFileSystem,
                    children: rawFileSystem.children.filter(child => selectedIds.has(child.id))
                };
                onImport(importedSystem);
            };

            const handleImportAllNow = () => {
                const importedSystem = {
                    ...rawFileSystem,
                    children: rawFileSystem.children.slice()
                };
                onImport(importedSystem);
            };

            return (
                <div className="min-h-screen bg-gray-900 p-6">
                    <div className="max-w-4xl mx-auto bg-gray-800 rounded-lg p-8 page-fade">
                        <h1 className="text-3xl font-bold text-white mb-2">Import Media</h1>
                        <p className="text-gray-400 mb-4">Select the top-level files and folders you want to import.</p>
                        <div className="flex items-center flex-wrap gap-2 sm:gap-4 mb-4">
                            <button onClick={handleSelectAll} className="bg-gray-700 text-white px-4 py-1 rounded-md hover:bg-gray-600 transition-colors text-sm">Select All</button>
                            <button onClick={handleDeselectAll} className="bg-gray-700 text-white px-4 py-1 rounded-md hover:bg-gray-600 transition-colors text-sm">Deselect All</button>
                            <button onClick={handleImportAllNow} className="bg-blue-600 text-white px-4 py-1 rounded-md hover:bg-blue-700 transition-colors text-sm">Import All</button>
                        </div>
                        <div className="bg-gray-900 p-4 rounded-lg max-h-[60vh] overflow-y-auto">
                            {rawFileSystem.children.map(node => (
                                <div key={node.id} className="flex items-center my-1 p-2 rounded-md hover:bg-gray-700">
                                    <input type="checkbox" className="h-4 w-4 rounded text-blue-600 focus:ring-blue-500" checked={selectedIds.has(node.id)} onChange={() => handleToggle(node)} />
                                    <span className="ml-3 text-gray-300">{node.name}</span>
                                </div>
                            ))}
                        </div>
                        <div className="mt-6 flex justify-end gap-4">
                            <button onClick={onCancel} className="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-500 transition-colors">Cancel</button>
                            <button onClick={handleImportClick} className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">Import Selected</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const FileUpload = ({ onFolderUploaded, onFolderLoadedDirect, showToast }) => {
            const [isUploading, setIsUploading] = useState(false);
            const folderInputRef = useRef(null);

            // --- IndexedDB helpers for persisting directory handles ---
            const openDB = () => new Promise((resolve, reject) => {
                const request = indexedDB.open('fappr', 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            const idbGet = async (key) => {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('handles', 'readonly');
                    const store = tx.objectStore('handles');
                    const req = store.get(key);
                    req.onsuccess = async () => {
                        if (req.result !== undefined) { resolve(req.result); return; }
                        // Fallback migration: try legacy DB name 'roostr'
                        try {
                            const legacy = await new Promise((res2, rej2) => {
                                const r2 = indexedDB.open('roostr', 1);
                                r2.onsuccess = () => {
                                    try {
                                        const db2 = r2.result;
                                        const tx2 = db2.transaction('handles', 'readonly');
                                        const st2 = tx2.objectStore('handles');
                                        const q = st2.get(key);
                                        q.onsuccess = () => res2(q.result);
                                        q.onerror = () => rej2(q.error);
                                    } catch (e) { rej2(e); }
                                };
                                r2.onerror = () => rej2(r2.error);
                            });
                            resolve(legacy);
                        } catch(_) { resolve(undefined); }
                    };
                    req.onerror = () => reject(req.error);
                });
            };

            const idbSet = async (key, value) => {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('handles', 'readwrite');
                    const store = tx.objectStore('handles');
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            };

            const verifyPermission = async (dirHandle) => {
                if (!dirHandle || !dirHandle.queryPermission || !dirHandle.requestPermission) return false;
                let perm = await dirHandle.queryPermission({ mode: 'read' });
                if (perm === 'granted') return true;
                if (perm === 'prompt') {
                    perm = await dirHandle.requestPermission({ mode: 'read' });
                    return perm === 'granted';
                }
                return false;
            };
            
            const processFolder = async (fileList) => {
                setIsUploading(true);
                const root = { id: 'root', type: 'folder', name: 'root', children: [], path: '' };

                // Pre-scan: map of relativePath -> File for quick lookup (for hidden thumbnails)
                const fileMap = new Map();
                for (const f of fileList) {
                    if (!f.webkitRelativePath) continue;
                    const rel = f.webkitRelativePath.split('/').filter(p=>p).join('/');
                    fileMap.set(rel, f);
                }

                for (const file of fileList) {
                    if (!file.webkitRelativePath) continue;
                    
                    const pathParts = file.webkitRelativePath.split('/').filter(p => p);
                    if (pathParts.length === 0 || pathParts.some(part => part.startsWith('.'))) continue;

                    let currentNode = root;
                    for (const folderName of pathParts.slice(0, -1)) {
                        let folderNode = currentNode.children.find(c => c.name === folderName && c.type === 'folder');
                        if (!folderNode) {
                            const folderPath = (currentNode.path ? currentNode.path + '/' : '') + folderName;
                            folderNode = { id: `folder-${Date.now()}-${Math.random()}`, type: 'folder', name: folderName, children: [], thumbnail: null, path: folderPath };
                            currentNode.children.push(folderNode);
                        }
                        currentNode = folderNode;
                    }
                    
                    const itemName = pathParts[pathParts.length - 1];
                    const url = URL.createObjectURL(file);
                    const isVideo = file.type.startsWith('video/') || isVideoFile(itemName);

                    if (file.type.startsWith('image/')) {
                        currentNode.children.push({ id: `${Date.now()}-${itemName}`, name: itemName, type: 'photo', displaySrc: url, thumbnail: url, size: file.size || 0, modifiedAt: file.lastModified || Date.now() });
                    } else if (isVideo) {
                        // Try hidden thumbnail .<basename>.jpg in same directory
                        const dirPath = pathParts.slice(0,-1).join('/');
                        const base = itemName.replace(/\.[^.]+$/, '');
                        const hiddenRel = [dirPath, `.${base}.jpg`].filter(Boolean).join('/');
                        let hiddenThumb = null;
                        if (fileMap.has(hiddenRel)) {
                            try { hiddenThumb = URL.createObjectURL(fileMap.get(hiddenRel)); } catch(_) {}
                        }
                        currentNode.children.push({ 
                            id: `${Date.now()}-${itemName}`, 
                            name: itemName, 
                            type: 'video', 
                            displaySrc: url, 
                            thumbnail: hiddenThumb,
                            unsupported: !isBrowserSupportedVideo(itemName),
                            size: file.size || 0,
                            modifiedAt: file.lastModified || Date.now()
                        });
                    }
                }
                
                const assignFolderThumbnailsPostOrder = (folderNode) => {
                    for (const child of folderNode.children) {
                        if (child.type === 'folder') assignFolderThumbnailsPostOrder(child);
                    }
                    if (folderNode.thumbnail) return;
                    const directMediaChild = folderNode.children.find(child => child.type === 'photo');
                    if (directMediaChild) {
                        folderNode.thumbnail = directMediaChild.thumbnail;
                    } else {
                        const subfolderWithThumbnail = folderNode.children.find(child => child.type === 'folder' && child.thumbnail);
                        if (subfolderWithThumbnail) folderNode.thumbnail = subfolderWithThumbnail.thumbnail;
                    }
                };
                
                assignFolderThumbnailsPostOrder(root);
                await assignFolderThumbnailsFromVideos(root);
                // Apply hidden folder thumbnails .<folder-name>.jpg
                const applyHiddenFolderThumbs = (node) => {
                    if (node.type === 'folder') {
                        const hiddenName = `.${node.name}.jpg`;
                        const rel = [node.path, hiddenName].filter(Boolean).join('/');
                        if (fileMap.has(rel)) {
                            try { node.thumbnail = URL.createObjectURL(fileMap.get(rel)); } catch(_) {}
                        }
                        for (const c of node.children) applyHiddenFolderThumbs(c);
                    }
                };
                applyHiddenFolderThumbs(root);
                // Apply non-hidden cover pairing and hide used images
                pairCoversAndHide(root);
                computeFolderAggregates(root);
                onFolderUploaded(root);
            };

            // Build a file tree from a FileSystemDirectoryHandle
            const processDirectoryHandle = async (dirHandle, directLoad = true) => {
                setIsUploading(true);
                try {
                    const root = { id: 'root', type: 'folder', name: dirHandle.name || 'root', children: [], path: dirHandle.name || '' };

                    const getOrCreateFolder = (partsArr) => {
                        let node = root;
                        for (const folderName of partsArr) {
                            let next = node.children.find(c => c.type === 'folder' && c.name === folderName);
                            if (!next) {
                                const folderPath = (node.path ? node.path + '/' : '') + folderName;
                                next = { id: `folder-${Date.now()}-${Math.random()}`, type: 'folder', name: folderName, children: [], thumbnail: null, path: folderPath };
                                node.children.push(next);
                            }
                            node = next;
                        }
                        return node;
                    };

                    const gather = async (handle, parts = []) => {
                        // Ensure current folder node exists
                        const currentFolderNode = getOrCreateFolder(parts);
                        for await (const [name, entry] of handle.entries()) {
                            if (entry.kind === 'file') {
                                // Hidden folder thumbnail .<folder-name>.jpg
                                if (name.startsWith('.') && name.endsWith('.jpg')) {
                                    const folderName = parts[parts.length-1];
                                    if (folderName && name === `.${folderName}.jpg` && !currentFolderNode.thumbnail) {
                                        try { const file = await entry.getFile(); currentFolderNode.thumbnail = URL.createObjectURL(file); } catch(_) {}
                                    }
                                }
                                if (name.startsWith('.')) continue; // other hidden files ignored
                                const file = await entry.getFile();
                                const url = URL.createObjectURL(file);
                                const isVideo = file.type.startsWith('video/') || isVideoFile(name);

                                let currentNode = currentFolderNode;

                                if (file.type.startsWith('image/')) {
                                    currentNode.children.push({ id: `${Date.now()}-${name}`, name: name, type: 'photo', displaySrc: url, thumbnail: url, size: file.size || 0, modifiedAt: file.lastModified || Date.now() });
                                } else if (isVideo) {
                                    // Try hidden thumbnail .<basename>.jpg in this directory
                                    const base = name.replace(/\.[^.]+$/, '');
                                    let hiddenThumb = null;
                                    try {
                                        const hiddenHandle = await handle.getFileHandle(`.${base}.jpg`);
                                        const hiddenFile = await hiddenHandle.getFile();
                                        hiddenThumb = URL.createObjectURL(hiddenFile);
                                    } catch(_) {}
                                    currentNode.children.push({ id: `${Date.now()}-${name}`, name: name, type: 'video', displaySrc: url, thumbnail: hiddenThumb, unsupported: !isBrowserSupportedVideo(name), size: file.size || 0, modifiedAt: file.lastModified || Date.now() });
                                }
                            } else if (entry.kind === 'directory') {
                                // Skip hidden directories (do not show in browser)
                                if (name.startsWith('.')) continue;
                                // Create folder node immediately so empty folders persist
                                getOrCreateFolder([...parts, name]);
                                // Assign hidden folder thumbnail if present within subdir
                                try {
                                    const thumbHandle = await entry.getFileHandle(`.${name}.jpg`);
                                    const thumbFile = await thumbHandle.getFile();
                                    const node = getOrCreateFolder([...parts, name]);
                                    node.thumbnail = URL.createObjectURL(thumbFile);
                                } catch(_) {}
                                await gather(entry, [...parts, name]);
                            }
                        }
                    };

                    await gather(dirHandle, []);

                    const assignFolderThumbnailsPostOrder = (folderNode) => {
                        for (const child of folderNode.children) {
                            if (child.type === 'folder') assignFolderThumbnailsPostOrder(child);
                        }
                        if (folderNode.thumbnail) return;
                        const directMediaChild = folderNode.children.find(child => child.type === 'photo');
                        if (directMediaChild) {
                            folderNode.thumbnail = directMediaChild.thumbnail;
                        } else {
                            const subfolderWithThumbnail = folderNode.children.find(child => child.type === 'folder' && child.thumbnail);
                            if (subfolderWithThumbnail) folderNode.thumbnail = subfolderWithThumbnail.thumbnail;
                        }
                    };
                    assignFolderThumbnailsPostOrder(root);
                    await assignFolderThumbnailsFromVideos(root);
                    // Pair non-hidden cover images and hide them
                    pairCoversAndHide(root);
                    computeFolderAggregates(root);

                    if (directLoad && onFolderLoadedDirect) {
                        onFolderLoadedDirect(root);
                    } else if (onFolderUploaded) {
                        onFolderUploaded(root);
                    }
                } catch (e) {
                    console.error(e);
                    showToast && showToast('Failed to open last folder.');
                } finally {
                    setIsUploading(false);
                }
            };

            const openLastFolder = async () => {
                if (!('showDirectoryPicker' in window) && !('indexedDB' in window)) {
                    showToast && showToast('Not supported in this browser.');
                    return;
                }
                try {
                    const stored = await idbGet('lastDirectory');
                    let handle = stored;
                    if (!handle) {
                        if (!window.showDirectoryPicker) {
                            showToast && showToast('No saved folder. Use Choose Folder first.');
                            return;
                        }
                        handle = await window.showDirectoryPicker();
                        await idbSet('lastDirectory', handle);
                    }
                    const ok = await verifyPermission(handle);
                    if (!ok) {
                        showToast && showToast('Permission denied for last folder.');
                        return;
                    }
                    await processDirectoryHandle(handle, true);
                } catch (e) {
                    console.error(e);
                    showToast && showToast('Could not open last folder.');
                }
            };

            const chooseFolder = async () => {
                if (window.showDirectoryPicker) {
                    try {
                        const handle = await window.showDirectoryPicker();
                        await idbSet('lastDirectory', handle);
                        const ok = await verifyPermission(handle);
                        if (!ok) {
                            showToast && showToast('Permission denied.');
                            return;
                        }
                        await processDirectoryHandle(handle, false); // go to Import screen
                        return;
                    } catch (e) {
                        // Fall back to input if user cancels or API fails
                        console.warn('showDirectoryPicker failed, falling back to input', e);
                    }
                }
                folderInputRef.current?.click();
            };
            
            const chooseFromDropbox = () => {
                try {
                    if (!window.Dropbox || !window.Dropbox.choose) {
                        showToast && showToast('Dropbox Chooser not available. Check app key and network.');
                        return;
                    }
                    const upgradeThumbnail = (url) => {
                        if (!url) return null;
                        try {
                            const u = new URL(url);
                            // Increase thumbnail bounding box if present
                            if (u.searchParams.has('bounding_box')) {
                                u.searchParams.set('bounding_box', '256');
                                u.searchParams.set('mode', 'fit');
                            }
                            return u.toString();
                        } catch (_) {
                            return url;
                        }
                    };
                    window.Dropbox.choose({
                        linkType: 'direct',
                        multiselect: true,
                        folderselect: false,
                        extensions: ['.jpg','.jpeg','.png','.gif','.webp','.mp4','.mov','.webm','.ogg','.mkv','.avi','.wmv'],
                        success: (files) => {
                            // Build a root from selected files
                            const root = { id: 'root', type: 'folder', name: 'Dropbox', children: [] };
                            // Index potential cover images by normalized base name so we can pair with videos
                            const normalizeBase = (name) => {
                                const base = (name || '').replace(/\.[^.]+$/, '');
                                return base
                                    .replace(/[-_ ]?(cover|thumbnail|thumb|poster|folder)$/i, '')
                                    .toLowerCase();
                            };
                            const isImageName = (n) => /\.(jpg|jpeg|png|gif|webp)$/i.test(n || '');
                            const imageIndex = new Map();
                            for (const f of files) {
                                if ((f.name || '').startsWith('.')) continue; // skip dotfiles
                                if (!isImageName(f.name || '')) continue;
                                const key = normalizeBase(f.name || '');
                                if (!imageIndex.has(key)) imageIndex.set(key, []);
                                imageIndex.get(key).push(f);
                            }
                            // Track images used as covers so we can optionally suppress them as standalone photos
                            const usedAsCover = new Set();

                            for (const f of files) {
                                // Skip hidden dotfiles
                                if ((f.name || '').startsWith('.')) continue;
                                const lower = (f.name || '').toLowerCase();
                                const isVideo = isVideoFile(lower);
                                const isImage = !isVideo && isImageName(lower);
                                if (!isVideo && !isImage) continue;

                                if (isVideo) {
                                    // Try pair with a selected image with same base or base+cover/thumbnail
                                    const key = normalizeBase(f.name || '');
                                    let cover = null;
                                    const candidates = imageIndex.get(key) || [];
                                    if (candidates.length > 0) {
                                        // Prefer an image whose base actually includes a cover marker
                                        const preferred = candidates.find(c => /(cover|thumbnail|thumb|poster|folder)\.[^.]+$/i.test(c.name || '')) || candidates[0];
                                        cover = preferred;
                                        usedAsCover.add(preferred);
                                    }
                                    const thumb = cover ? (cover.link) : upgradeThumbnail(f.thumbnailLink || '');
                                    root.children.push({ id: `db-${Date.now()}-${Math.random()}`, name: f.name, type: 'video', displaySrc: f.link, thumbnail: thumb || null, unsupported: !isBrowserSupportedVideo(f.name || ''), size: f.bytes || 0, modifiedAt: Date.now() });
                                } else if (isImage) {
                                    // Only include as a photo if not already used as a cover
                                    if (usedAsCover.has(f)) continue;
                                    root.children.push({ id: `db-${Date.now()}-${Math.random()}`, name: f.name, type: 'photo', displaySrc: f.link, thumbnail: f.link, size: f.bytes || 0, modifiedAt: Date.now() });
                                }
                            }
                            if (root.children.length === 0) {
                                showToast && showToast('No supported media selected.');
                                return;
                            }
                            onFolderUploaded(root);
                        },
                        cancel: () => {}
                    });
                } catch (e) {
                    console.error(e);
                    showToast && showToast('Dropbox selection failed.');
                }
            };

            return (
                <div className="min-h-screen bg-gray-900 p-6 flex items-center justify-center page-fade">
                    <div className="max-w-2xl w-full">
                        <div className="flex items-center justify-center mb-8">
                            <img src="logo.png" alt="fappr Logo" className="w-16 h-16 mr-4" />
                            <h1 className="text-4xl font-bold text-white">fappr</h1>
                        </div>
                        <div className="border-2 border-dashed rounded-lg p-12 text-center border-gray-600 hover:border-blue-500 shimmer-box page-fade">
                            {isUploading ? (
                                <div className="flex flex-col items-center">
                                    <div className="spinner mb-4"></div>
                                    <p className="text-white text-lg">Processing your folder...</p>
                                </div>
                            ) : (
                                <>
                                    <div className="mb-4 flex justify-center text-gray-400">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                        </svg>
                                    </div>
                                    <h2 className="text-2xl font-semibold text-white mb-2">Select a Root Folder</h2>
                                    <p className="text-gray-400 mb-6">You will be able to select which files and folders to import on the next screen.</p>
                                    <div className="flex flex-col sm:flex-row gap-3 justify-center">
                                        <button onClick={chooseFolder} className="px-6 py-3 rounded-lg font-semibold transition-colors bg-blue-600 text-white hover:bg-blue-700">
                                            Choose Folder
                                        </button>
                                        <button onClick={openLastFolder} className="px-6 py-3 rounded-lg font-semibold transition-colors bg-blue-600 text-white hover:bg-blue-700">
                                            Last Folder
                                        </button>
                                        <button onClick={chooseFromDropbox} className="px-6 py-3 rounded-lg font-semibold transition-colors bg-white text-gray-900 hover:bg-gray-100 border border-gray-300 inline-flex items-center justify-center gap-2 w-full sm:w-auto text-center">
                                            <span className="inline-block" aria-hidden="true">
                                                <svg width="18" height="18" viewBox="0 -1.5 48 48" xmlns="http://www.w3.org/2000/svg">
                                                    <g fill="#0F82E2" fillRule="evenodd">
                                                        <path d="M24,25.533255 L14.1195,33.84573 L0,24.553538 L9.7635,16.67347 L23.999971,25.533238 L38.2362,16.672109 L47.9997,24.55369 L33.8802,33.845881 L23.9997,25.533406 Z M14.1198, -0.033 L0.0003,9.259191 L9.7638,17.13926 L24.0003,8.279475 L14.1198,-0.033 Z M24.02895,27.321692 L14.11995,35.609976 L9.87945,32.818993 L9.87945,35.947132 L24.02895,44.5 L38.17845,35.947132 L38.17845,32.818993 L33.93795,35.609976 L24.02895,27.321692 Z M48,9.292343 L33.8805,0.000151 L24,8.312626 L38.2365,17.172411 L48,9.292343 Z" />
                                                    </g>
                                                </svg>
                                            </span>
                                            <span>Dropbox</span>
                                        </button>
                                    </div>
                                    <div className="max-w-xl mx-auto mt-4 space-y-2">
                                        <div className="rounded-md text-gray-300 text-xs leading-snug px-4 py-3 text-center">
                                            No data ever leaves your computer. Everything runs locally in your browser.
                                        </div>
                                        <div className="mt-2 flex justify-center">
                                            <a id="downloadZip" href="/roostr/V1/roostr.zip" className="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 transition-colors text-xs" aria-label="Download Website">
                                                Download Website
                                            </a>
                                        </div>
                                    </div>
                                    <input ref={folderInputRef} type="file" webkitdirectory="" directory="" onChange={(e) => processFolder(e.target.files)} className="hidden" />
                                </>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Collage templates (20 examples) using normalized rects
        const COLLAGE_TEMPLATES = [
            { id: '1up', name: '1 Up Full', rects: [{x:0,y:0,w:100,h:100}] },
            { id: '2v', name: '2 Up Vertical', rects: [{x:0,y:0,w:50,h:100},{x:50,y:0,w:50,h:100}] },
            { id: '2h', name: '2 Up Horizontal', rects: [{x:0,y:0,w:100,h:50},{x:0,y:50,w:100,h:50}] },
            { id: '3left', name: '3 Up Left', rects: [{x:0,y:0,w:50,h:100},{x:50,y:0,w:50,h:50},{x:50,y:50,w:50,h:50}] },
            { id: '2x2', name: '2×2 Grid', rects: [{x:0,y:0,w:50,h:50},{x:50,y:0,w:50,h:50},{x:0,y:50,w:50,h:50},{x:50,y:50,w:50,h:50}] },
            { id: '3v', name: '3 Vertical Thirds', rects: [{x:0,y:0,w:33.333,h:100},{x:33.333,y:0,w:33.334,h:100},{x:66.667,y:0,w:33.333,h:100}] },
            { id: '3h', name: '3 Horizontal Thirds', rects: [{x:0,y:0,w:100,h:33.333},{x:0,y:33.333,w:100,h:33.334},{x:0,y:66.667,w:100,h:33.333}] },
            { id: '2top3bot', name: '2 Top / 3 Bottom', rects: [{x:0,y:0,w:50,h:50},{x:50,y:0,w:50,h:50},{x:0,y:50,w:33.333,h:50},{x:33.333,y:50,w:33.334,h:50},{x:66.667,y:50,w:33.333,h:50}] },
            { id: '3top2bot', name: '3 Top / 2 Bottom', rects: [{x:0,y:0,w:33.333,h:50},{x:33.333,y:0,w:33.334,h:50},{x:66.667,y:0,w:33.333,h:50},{x:0,y:50,w:50,h:50},{x:50,y:50,w:50,h:50}] },
            { id: 'l2_3', name: 'Left 2/3 + Right Stacked', rects: [{x:0,y:0,w:66.667,h:100},{x:66.667,y:0,w:33.333,h:50},{x:66.667,y:50,w:33.333,h:50}] },
            { id: 'r2_3', name: 'Right 2/3 + Left Stacked', rects: [{x:33.333,y:0,w:66.667,h:100},{x:0,y:0,w:33.333,h:50},{x:0,y:50,w:33.333,h:50}] },
            { id: 't2_3', name: 'Top 2/3 + Two Bottom', rects: [{x:0,y:0,w:100,h:66.667},{x:0,y:66.667,w:50,h:33.333},{x:50,y:66.667,w:50,h:33.333}] },
            { id: 'b2_3', name: 'Bottom 2/3 + Two Top', rects: [{x:0,y:33.333,w:100,h:66.667},{x:0,y:0,w:50,h:33.333},{x:50,y:0,w:50,h:33.333}] },
            { id: '4v', name: 'Four Vertical Quarters', rects: [{x:0,y:0,w:25,h:100},{x:25,y:0,w:25,h:100},{x:50,y:0,w:25,h:100},{x:75,y:0,w:25,h:100}] },
            { id: '4h', name: 'Four Horizontal Quarters', rects: [{x:0,y:0,w:100,h:25},{x:0,y:25,w:100,h:25},{x:0,y:50,w:100,h:25},{x:0,y:75,w:100,h:25}] },
            { id: '3x3', name: '3×3 Grid', rects: Array.from({length:9}, (_,i)=>({x:(i%3)*33.333,y:Math.floor(i/3)*33.333,w:33.333,h:33.333})) },
            { id: '5v', name: 'Five Columns', rects: Array.from({length:5}, (_,i)=>({x:i*20,y:0,w:20,h:100})) },
            { id: '5h', name: 'Five Rows', rects: Array.from({length:5}, (_,i)=>({x:0,y:i*20,w:100,h:20})) },
            { id: 'stagger6', name: 'Staggered 6', rects: [
                {x:0,y:0,w:50,h:40},{x:50,y:0,w:50,h:40},
                {x:0,y:40,w:33.333,h:60},{x:33.333,y:40,w:33.334,h:60},{x:66.667,y:40,w:33.333,h:60},
            ] },
            { id: 'mosaic', name: 'Mosaic 6', rects: [{x:0,y:0,w:50,h:50},{x:50,y:0,w:50,h:50},{x:0,y:50,w:33.333,h:50},{x:33.333,y:50,w:33.334,h:50},{x:66.667,y:50,w:33.333,h:50},{x:25,y:25,w:50,h:50}] },
        ];

        const App = () => {
            const [fileSystem, setFileSystem] = useState(null);
            const [rawFileSystem, setRawFileSystem] = useState(null);
            const [currentPath, setCurrentPath] = useState([]);
            const [viewingMedia, setViewingMedia] = useState({ media: null, collection: [], index: -1 });
            const [selectionMode, setSelectionMode] = useState(false);
            const [selectedItems, setSelectedItems] = useState([]);
            const [isRecursiveView, setIsRecursiveView] = useState(false);
            const [toastMessage, setToastMessage] = useState(null);
            const [collage, setCollage] = useState({ active: false, template: null, slots: [], picking: -1, showPicker: false });
            const [pip, setPip] = useState({ picking: false, resume: null, items: [] });
            const [specialView, setSpecialView] = useState(null); // null | 'favorites'
            const [favorites, setFavorites] = useState(() => {
                try { return JSON.parse(localStorage.getItem('fappr.favorites') || '[]'); } catch(_) { return []; }
            });
            useEffect(() => { try { localStorage.setItem('fappr.favorites', JSON.stringify(favorites)); } catch(_){} }, [favorites]);

            // On startup, backfill persistent thumbnails for favorites lacking them
            useEffect(() => {
                let cancelled = false;
                (async () => {
                    const needs = favorites.filter(f => !f.thumbnail || String(f.thumbnail).startsWith('blob:'));
                    if (needs.length === 0) return;
                    const updates = await Promise.all(needs.map(ensureFavoriteThumbnail));
                    if (cancelled) return;
                    setFavorites(prev => prev.map(f => {
                        const u = updates.find(x => x.key === f.key);
                        return u ? u : f;
                    }));
                })();
                return () => { cancelled = true; };
            }, []);

            const showToast = useCallback((msg) => {
                setToastMessage(msg);
                setTimeout(() => setToastMessage(null), 2500);
            }, []);

            const handleFolderUploaded = (rawSystem) => {
                const topLevelNode = (rawSystem && rawSystem.children.length === 1 && rawSystem.children[0].type === 'folder')
                    ? rawSystem.children[0]
                    : rawSystem;
                setRawFileSystem(topLevelNode);
            };

            const handleImport = (importedSystem) => {
                setRawFileSystem(null);
                setFileSystem(importedSystem);
                setCurrentPath([importedSystem.name]);
                setSpecialView(null);
            };
            
            const handleCancelImport = () => {
                setRawFileSystem(null);
                setIsRecursiveView(false);
            };

            const startCollage = () => {
                // Block on small screens
                if (window.matchMedia('(max-width: 767px)').matches) {
                    showToast('Collage is desktop-only.');
                    return;
                }
                setCollage({ active: true, template: null, slots: [], picking: -1, showPicker: true });
            };
            const chooseTemplate = (tpl) => {
                const slots = tpl.rects.map(()=>({ type:'empty' }));
                setCollage(prev => ({ ...prev, template: tpl, slots, showPicker: false }));
            };
            const backFromCollage = () => setCollage(prev => ({ ...prev, active: false, showPicker: false, picking: -1 }));
            const pickSlot = (index) => setCollage(prev => ({ ...prev, picking: index }));
            const clearSlot = (index) => setCollage(prev => ({ ...prev, slots: prev.slots.map((s,i)=> i===index? { type:'empty' } : s) }));

            const toggleSelection = (item) => {
                setSelectedItems(prev => 
                    prev.some(selected => selected.id === item.id)
                        ? prev.filter(selected => selected.id !== item.id)
                        : [...prev, item]
                );
            };

            const clearSelection = () => {
                setSelectedItems([]);
                setSelectionMode(false);
            };

            const handleViewSelected = () => {
                const mediaFiles = selectedItems.filter(item => item.type === 'photo' || item.type === 'video');
                if (mediaFiles.length > 0) onMediaClick(mediaFiles[0], mediaFiles);
            };

            const getCurrentFolder = () => {
                if (!fileSystem || !currentPath.length) return null;
                let currentNode = fileSystem;
                for (let i = 1; i < currentPath.length; i++) {
                    const nextNode = currentNode.children.find(c => c.name === currentPath[i] && c.type === 'folder');
                    if (!nextNode) return null;
                    currentNode = nextNode;
                }
                return currentNode;
            };
            
            const getRecursiveItems = useCallback((folder) => {
                let items = [];
                const traverse = (currentNode) => {
                    for (const child of currentNode.children) {
                        if (child.type === 'folder') {
                            traverse(child);
                        } else {
                            items.push(child);
                        }
                    }
                };
                if (folder) traverse(folder);
                return items;
            }, []);

            const navigateToFolder = (folderName) => {
                setIsRecursiveView(false);
                setCurrentPath(prev => [...prev, folderName]);
            };
            const navigateByBreadcrumb = (pathIndex) => {
                setIsRecursiveView(false);
                setCurrentPath(prev => prev.slice(0, pathIndex + 1));
            };
            const handleUploadNew = () => {
                setFileSystem(null);
                setIsRecursiveView(false);
            }
            
            const onMediaClick = (media, collection) => {
                // Collage selection intercept
                if (collage.active && collage.picking >= 0) {
                    if (media.type === 'folder') return; // ignore
                    const payload = { type: media.type, src: media.displaySrc, path: currentPath.join('/') + '/' + media.name };
                    setCollage(prev => ({ ...prev, slots: prev.slots.map((s,i)=> i===prev.picking? { type:'media', media: payload } : s), picking: -1 }));
                    return;
                }
                // PIP picking intercept
                if (pip.picking) {
                    if (media.type === 'folder') return; // ignore; let user navigate
                    if (media.type === 'video' && media.unsupported) { showToast('Unsupported video for PIP.'); return; }
                    setPip(prev => {
                        if ((prev.items || []).length >= 4) {
                            showToast('Maximum 4 PIPs');
                            return { ...prev, picking: false };
                        }
                        const used = new Set((prev.items||[]).map(i => `${i.position.x}-${i.position.y}`));
                        const corners = [
                            { x:'right', y:'bottom' },
                            { x:'left', y:'bottom' },
                            { x:'right', y:'top' },
                            { x:'left', y:'top' }
                        ];
                        const pos = corners.find(c => !used.has(`${c.x}-${c.y}`)) || { x:'right', y:'bottom' };
                        const nextItems = [ ...(prev.items||[]), { media: { type: media.type, src: media.displaySrc, name: media.name }, position: pos } ];
                        return { ...prev, picking: false, items: nextItems };
                    });
                    // Resume viewer with previous media
                    if (pip.resume && pip.resume.collection && pip.resume.collection.length > 0) {
                        const idx = Math.max(0, Math.min(pip.resume.collection.length - 1, pip.resume.index || 0));
                        const resumeMedia = pip.resume.collection[idx];
                        setViewingMedia({ media: resumeMedia, collection: pip.resume.collection, index: idx });
                        setTimeout(()=> setToastMessage(null), 0);
                    }
                    return;
                }
                if (media && media.type === 'video' && media.unsupported) {
                    showToast('This video format is not supported for local playback.');
                    return;
                }
                const index = collection.findIndex(item => item.id === media.id);
                setViewingMedia({ media, collection, index });
            };
            const handleCloseViewer = () => setViewingMedia({ media: null, collection: [], index: -1 });
            const handleNext = () => setViewingMedia(prev => {
                const nextIndex = (prev.index + 1) % prev.collection.length;
                return { ...prev, media: prev.collection[nextIndex], index: nextIndex };
            });
            const handlePrevious = () => setViewingMedia(prev => {
                const prevIndex = (prev.index - 1 + prev.collection.length) % prev.collection.length;
                return { ...prev, media: prev.collection[prevIndex], index: prevIndex };
            });
            
            const currentFolder = getCurrentFolder();
            
            if (rawFileSystem) return <ImportScreen rawFileSystem={rawFileSystem} onImport={handleImport} onCancel={handleCancelImport} />;
            if (!currentFolder && specialView !== 'favorites') return <FileUpload onFolderUploaded={handleFolderUploaded} onFolderLoadedDirect={(system)=>{ setFileSystem(system); setCurrentPath([system.name]); }} showToast={showToast} />;
            
            const displayedItems = specialView === 'favorites' ? favorites.map((f, i) => ({
                id: f.key || `fav-${i}`,
                name: f.name,
                type: f.type,
                displaySrc: f.displaySrc || f.src,
                // Photos should always have a visible thumbnail; videos may generate at runtime
                thumbnail: f.type === 'photo' ? (f.thumbnail || f.displaySrc || f.src) : (f.thumbnail || null),
                unsupported: !!f.unsupported,
            })) : (isRecursiveView ? getRecursiveItems(currentFolder) : currentFolder.children);
            const hasSubfolders = specialView === 'favorites' ? false : currentFolder.children.some(item => item.type === 'folder');

            const makeFavKey = (item) => `${item.type}|${item.name}|${item.displaySrc || item.src || ''}`;
            const isFavorite = (item) => favorites.some(f => f.key === makeFavKey(item));
            // Helpers to capture thumbnails that persist across refresh
            const createImageThumbDataURL = (src, maxSize=512) => new Promise((resolve, reject) => {
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        try {
                            const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
                            const w = Math.max(1, Math.floor(img.width * scale));
                            const h = Math.max(1, Math.floor(img.height * scale));
                            const canvas = document.createElement('canvas');
                            canvas.width = w; canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, w, h);
                            resolve(canvas.toDataURL('image/jpeg', 0.85));
                        } catch (e) { resolve(src); }
                    };
                    img.onerror = () => resolve(src);
                    img.src = src;
                } catch (e) { resolve(src); }
            });

            const ensureFavoriteThumbnail = async (favEntry) => {
                try {
                    if (favEntry.thumbnail && !String(favEntry.thumbnail).startsWith('blob:')) return favEntry; // already persistent
                    if (favEntry.type === 'photo') {
                        const src = favEntry.displaySrc || favEntry.src || '';
                        if (!src) return favEntry;
                        const thumb = await createImageThumbDataURL(src);
                        return { ...favEntry, thumbnail: thumb };
                    } else if (favEntry.type === 'video') {
                        const src = favEntry.displaySrc || favEntry.src || '';
                        if (!src) return favEntry;
                        try {
                            const thumb = await generateVideoThumbnail(src);
                            return { ...favEntry, thumbnail: thumb };
                        } catch (_) { return favEntry; }
                    }
                } catch (_) { /* ignore */ }
                return favEntry;
            };

            const toggleFavorite = (item) => {
                const key = makeFavKey(item);
                setFavorites(prev => {
                    if (prev.some(f => f.key === key)) return prev.filter(f => f.key !== key);
                    const base = { key, type: item.type, name: item.name, displaySrc: item.displaySrc || item.src, thumbnail: item.thumbnail, unsupported: item.unsupported };
                    // Schedule thumbnail capture for persistence
                    (async () => {
                        const updated = await ensureFavoriteThumbnail(base);
                        setFavorites(cur => cur.map(f => f.key === key ? updated : f));
                    })();
                    return [...prev, base];
                });
            };

            const CollagePicker = ({ onChoose, onClose }) => (
                <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-6 page-fade">
                    <div className="bg-gray-800 rounded-xl p-6 max-w-5xl w-full">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-white text-xl font-semibold">Choose a Collage Layout</h2>
                            <button onClick={onClose} className="text-gray-300 hover:text-white">Close</button>
                        </div>
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                            {COLLAGE_TEMPLATES.map(tpl => (
                                <button key={tpl.id} onClick={() => onChoose(tpl)} className="bg-gray-700 hover:bg-gray-600 rounded-lg p-3">
                                    <div className="relative w-full" style={{paddingTop:'100%'}}>
                                        {tpl.rects.map((r, idx) => (
                                            <div key={idx} className="absolute bg-gray-900 border border-gray-500" style={{left:`${r.x}%`, top:`${r.y}%`, width:`${r.w}%`, height:`${r.h}%`}}></div>
                                        ))}
                                    </div>
                                    <div className="text-gray-200 text-xs mt-2 text-center">{tpl.name}</div>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );

            const CollageBuilder = ({ model, onToast, onUpdateSlotPan }) => {
                const boardRef = useRef(null);
                const [boardHeight, setBoardHeight] = useState(400);
                useEffect(() => {
                    const compute = () => {
                        const headerOffset = 140; // approx chrome height
                        const h = Math.max(320, window.innerHeight - headerOffset);
                        setBoardHeight(h);
                    };
                    compute();
                    window.addEventListener('resize', compute);
                    return () => window.removeEventListener('resize', compute);
                }, []);

                const videosRef = useRef([]);
                useEffect(() => { videosRef.current = videosRef.current.slice(0, (model.template?.rects.length||0)); });

                // D-Pad panning (no drag state needed)
                const [panIndex, setPanIndex] = useState(-1);

                const playAll = async () => {
                    let blocked = false;
                    for (const v of videosRef.current) { try { v && (await v.play()); } catch(e){ blocked = true; } }
                    if (blocked && onToast) onToast('Click to enable playback');
                };
                const pauseAll = () => { for (const v of videosRef.current) { try { v && v.pause(); } catch(e){} } };
                const muteAll = () => { for (const v of videosRef.current) { if (v) v.muted = true; } };
                const unmuteAll = () => { for (const v of videosRef.current) { if (v) v.muted = false; } };

                // Fullscreen support for collage
                const [isFs, setIsFs] = useState(!!document.fullscreenElement);
                useEffect(() => {
                    const onFs = () => setIsFs(!!document.fullscreenElement);
                    document.addEventListener('fullscreenchange', onFs);
                    return () => document.removeEventListener('fullscreenchange', onFs);
                }, []);
                const toggleFs = async () => {
                    try {
                        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
                        else await document.exitFullscreen();
                    } catch(_) {}
                };

                // Auto-hide toolbar after inactivity
                const [showToolbar, setShowToolbar] = useState(true);
                const toolbarTimerRef = useRef(null);
                const resetToolbarTimer = useCallback(() => {
                    setShowToolbar(true);
                    if (toolbarTimerRef.current) clearTimeout(toolbarTimerRef.current);
                    toolbarTimerRef.current = setTimeout(() => setShowToolbar(false), 2500);
                }, []);
                useEffect(() => {
                    // Start timer when component mounts or template changes
                    resetToolbarTimer();
                    return () => { if (toolbarTimerRef.current) clearTimeout(toolbarTimerRef.current); };
                }, [model.template, resetToolbarTimer]);

                return (
                    <div className="min-h-screen bg-gray-900 p-4 md:p-6" onMouseMove={resetToolbarTimer} onTouchStart={resetToolbarTimer}>
                        <div className="max-w-[100vw] mx-auto">
                            <header className={`sticky top-0 z-40 flex items-center gap-3 mb-4 bg-gray-900/95 border-b border-gray-700 backdrop-blur px-4 py-3 -mx-4 md:-mx-6 transition-opacity duration-300 ${showToolbar ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'}`}>
                                <button onClick={pauseAll} className="bg-blue-600 text-white px-3 py-2 rounded-md hover:bg-blue-700">Pause All</button>
                                <button onClick={playAll} className="bg-blue-600 text-white px-3 py-2 rounded-md hover:bg-blue-700">Play All</button>
                                <button onClick={muteAll} className="bg-blue-600 text-white px-3 py-2 rounded-md hover:bg-blue-700">Mute All</button>
                                <button onClick={unmuteAll} className="bg-blue-600 text-white px-3 py-2 rounded-md hover:bg-blue-700">Unmute All</button>
                                <button onClick={toggleFs} className="bg-blue-600 text-white px-3 py-2 rounded-md hover:bg-blue-700 inline-flex items-center gap-2">
                                    <svg className="h-4 w-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M8 3H5a2 2 0 0 0-2 2v3M16 21h3a2 2 0 0 0 2-2v-3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/>
                                    </svg>
                                    <span className="hidden sm:inline">{isFs ? 'Exit Full Screen' : 'Full Screen'}</span>
                                </button>
                                <button onClick={backFromCollage} className="ml-auto bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">Back</button>
                            </header>
                            {!model.template && (
                                <div className="text-gray-300 mb-3">Choose a template to begin.</div>
                            )}
                            <div ref={boardRef} className="collage-board" style={{height: boardHeight}}>
                                {model.template && model.template.rects.map((r, idx) => {
                                    const slot = model.slots[idx];
                                    const style = { left:`${r.x}%`, top:`${r.y}%`, width:`${r.w}%`, height:`${r.h}%` };
                                    const pan = (slot?.type === 'media' && slot.media?.pan) ? slot.media.pan : { x:50, y:50 };
                                    return (
                                        <div key={idx} className="collage-slot group" style={style} onClick={() => {
                                            if (!slot || slot.type !== 'media') {
                                                pickSlot(idx);
                                            }
                                        }}>
                                            {slot?.type !== 'media' ? (
                                                <div className="slot-empty">Click to add</div>
                                            ) : (
                                                <div className="slot-media">
                                                    {panIndex === idx ? (
                                                        // Pan mode: use transform wrapper; controls may be hidden by design
                                                        <div className="slot-pan-wrap">
                                                            {(() => { const MAX_SHIFT = 20; const tx = ((pan.x||50)-50)/50*MAX_SHIFT; const ty = ((pan.y||50)-50)/50*MAX_SHIFT; const tStyle = { transform: `translate(${tx}%, ${ty}%) scale(1.25)` };
                                                                return (
                                                                    <div className="slot-pan-inner" style={tStyle}>
                                                                        {slot.media.type === 'photo' ? (
                                                                            <img src={slot.media.src} alt="Collage" />
                                                                        ) : (
                                                                            <video ref={el => videosRef.current[idx] = el} src={slot.media.src} preload="metadata" loop muted playsInline onLoadedMetadata={(e)=>{ try { e.currentTarget.volume = 0.1; } catch(_){} }} />
                                                                        )}
                                                                    </div>
                                                                );})()}
                                                        </div>
                                                    ) : (
                                                        // Normal mode: render directly with controls and object-position to preserve controls
                                                        <>
                                                            {slot.media.type === 'photo' ? (
                                                                <img src={slot.media.src} alt="Collage" style={{ objectPosition: `${pan.x}% ${pan.y}%` }} />
                                                            ) : (
                                                                <video ref={el => videosRef.current[idx] = el} src={slot.media.src} preload="metadata" loop muted playsInline controls style={{ objectPosition: `${pan.x}% ${pan.y}%` }} onLoadedMetadata={(e)=>{ try { e.currentTarget.volume = 0.1; } catch(_){} }} />
                                                            )}
                                                        </>
                                                    )}
                                                    {/* Hover controls */}
                                                    <div className="absolute top-2 right-2 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition">
                                                        <button onClick={(e)=>{ e.stopPropagation(); pickSlot(idx); }} className="bg-black/60 text-white text-xs px-2 py-1 rounded">Replace</button>
                                                        <button onClick={(e)=>{ e.stopPropagation(); clearSlot(idx); }} className="bg-black/60 text-white text-xs px-2 py-1 rounded">Remove</button>
                                                        {panIndex !== idx ? (
                                                            <button onClick={(e)=>{ e.stopPropagation(); setPanIndex(idx); }} className="bg-black/60 text-white text-xs px-2 py-1 rounded">Pan</button>
                                                        ) : (
                                                            <button onClick={(e)=>{ e.stopPropagation(); setPanIndex(-1); }} className="bg-black/60 text-white text-xs px-2 py-1 rounded">Done</button>
                                                        )}
                                                    </div>
                                                    {/* D-Pad panning controls (only in Pan mode) */}
                                                    {panIndex === idx && (
                                                        <div className="absolute inset-0 flex items-center justify-center">
                                                            <div className="grid grid-cols-3 gap-1 bg-black/40 p-1 rounded-md">
                                                                <div></div>
                                                                <button type="button" aria-label="Pan Up" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); const ny=Math.max(0, pan.y-5); onUpdateSlotPan(idx,{x:pan.x,y:ny}); }} className="bg-black/60 hover:bg-black/80 text-white h-7 w-7 rounded flex items-center justify-center">▲</button>
                                                                <div></div>
                                                                <button type="button" aria-label="Pan Left" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); const nx=Math.max(0, pan.x-5); onUpdateSlotPan(idx,{x:nx,y:pan.y}); }} className="bg-black/60 hover:bg-black/80 text-white h-7 w-7 rounded flex items-center justify-center">◀</button>
                                                                <button type="button" aria-label="Center" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); onUpdateSlotPan(idx,{x:50,y:50}); }} className="bg-black/60 hover:bg-black/80 text-white h-7 w-7 rounded flex items-center justify-center">●</button>
                                                                <button type="button" aria-label="Pan Right" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); const nx=Math.min(100, pan.x+5); onUpdateSlotPan(idx,{x:nx,y:pan.y}); }} className="bg-black/60 hover:bg-black/80 text-white h-7 w-7 rounded flex items-center justify-center">▶</button>
                                                                <div></div>
                                                                <button type="button" aria-label="Pan Down" onClick={(e)=>{ e.preventDefault(); e.stopPropagation(); const ny=Math.min(100, pan.y+5); onUpdateSlotPan(idx,{x:pan.x,y:ny}); }} className="bg-black/60 hover:bg-black/80 text-white h-7 w-7 rounded flex items-center justify-center">▼</button>
                                                                <div></div>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <>
                    {!collage.active || collage.picking >= 0 ? (
                        <MediaLibrary 
                            items={displayedItems}
                            path={specialView === 'favorites' ? [(fileSystem?.name || currentPath[0] || 'root'), 'Favorites'] : currentPath}
                            onFolderClick={navigateToFolder}
                            onNavigate={navigateByBreadcrumb}
                            onMediaClick={onMediaClick}
                            onUploadNew={handleUploadNew}
                            onStartCollage={startCollage}
                            selectionMode={selectionMode}
                            setSelectionMode={setSelectionMode}
                            selectedItems={selectedItems}
                            toggleSelection={toggleSelection}
                            isRecursiveView={isRecursiveView}
                            setIsRecursiveView={setIsRecursiveView}
                            hasSubfolders={hasSubfolders}
                            specialView={specialView}
                            setSpecialView={setSpecialView}
                            isFavorite={isFavorite}
                            onToggleFavorite={toggleFavorite}
                            onClearFavorites={() => setFavorites([])}
                        />
                    ) : (
                        <CollageBuilder model={collage} onToast={showToast} onUpdateSlotPan={(index, pan) => setCollage(prev => ({ ...prev, slots: prev.slots.map((s,i)=> i===index && s.type==='media' ? ({ ...s, media: { ...s.media, pan } }) : s) }))} />
                    )}
                    {collage.active && collage.showPicker && (
                        <CollagePicker onChoose={chooseTemplate} onClose={()=>setCollage(prev=>({...prev, showPicker:false}))} />
                    )}
                    {viewingMedia.media && !collage.active && (
                        <MediaViewerModal 
                            media={viewingMedia.media}
                            collection={viewingMedia.collection}
                            currentIndex={viewingMedia.index}
                            onClose={handleCloseViewer}
                            onNext={handleNext}
                            onPrevious={handlePrevious}
                            onStartPip={() => {
                                // Pause handled in modal; switch to picking mode and close modal
                                setPip(prev => ({ ...prev, picking: true, resume: { collection: viewingMedia.collection, index: viewingMedia.index }, items: prev.items || [] }));
                                setViewingMedia({ media: null, collection: [], index: -1 });
                                showToast('Select a photo or video for Picture-in-Picture');
                            }}
                            pips={pip.items}
                            onClosePip={(index) => setPip(prev => ({ ...prev, items: (prev.items||[]).filter((_,i)=> i!==index) }))}
                            onMovePip={(index, dir) => setPip(prev => {
                                const items = [...(prev.items||[])];
                                const cur = items[index];
                                if (!cur) return prev;
                                const from = { ...cur.position };
                                const to = { ...from };
                                if (dir === 'left') to.x = 'left';
                                if (dir === 'right') to.x = 'right';
                                if (dir === 'up') to.y = 'top';
                                if (dir === 'down') to.y = 'bottom';
                                // Find if another PIP already at target corner
                                const j = items.findIndex((it,i) => i!==index && it.position && it.position.x === to.x && it.position.y === to.y);
                                if (j !== -1) {
                                    // Swap positions
                                    items[j] = { ...items[j], position: from };
                                }
                                items[index] = { ...cur, position: to };
                                return { ...prev, items };
                            })}
                        />
                    )}
                    {toastMessage && (
                        <div className="fixed bottom-6 left-1/2 -translate-x-1/2 bg-gray-900 text-white px-4 py-2 rounded-lg shadow-lg border border-gray-700 z-50 page-fade">
                            {toastMessage}
                        </div>
                    )}
                    {selectedItems.length > 0 && !collage.active && (
                        <div className="fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white px-4 py-2 rounded-lg shadow-lg flex items-center gap-4 z-50 page-fade">
                            <span className="font-semibold">{selectedItems.length} items selected</span>
                            <button onClick={handleViewSelected} className="bg-blue-600 px-4 py-2 rounded-md hover:bg-blue-700 transition-colors">View Selected</button>
                            <button onClick={clearSelection} className="bg-gray-600 px-4 py-2 rounded-md hover:bg-gray-500 transition-colors">Clear</button>
                        </div>
                    )}
                </>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
